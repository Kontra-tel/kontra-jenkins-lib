// This Pipeline lives in the *library repo* itself.
// It bootstraps/loads this same repo as a Shared Library and invokes vars/* steps.

pipeline {
  agent any

  tools {
    jdk    'temurin-21'
    gradle 'Gradle 9.1.0-rc-2' // used only if wrapper is missing
  }

  options {
    timestamps()
    disableConcurrentBuilds()
    skipStagesAfterUnstable()   // <- do not run later stages (e.g., Release) if tests mark UNSTABLE
  }

  parameters {
    // Semver controls (versioning only)
    booleanParam(name: 'FORCE_MAJOR',          defaultValue: false, description: 'Force major version bump (overrides !major token)')
    booleanParam(name: 'FORCE_MINOR',          defaultValue: false, description: 'Force minor version bump (overrides !minor token)')
    booleanParam(name: 'FORCE_PATCH',          defaultValue: false, description: 'Force patch version bump')
    booleanParam(name: 'STRICT_TAG_BASELINE',  defaultValue: false, description: 'Ignore version.txt; baseline only from tags')
    booleanParam(name: 'CUMULATIVE_PATCH',     defaultValue: false, description: 'Patch += commits since last tag (when baseline is a tag)')

    // Tagging controls (git tag creation and pushing)
    booleanParam(name: 'FORCE_RELEASE',        defaultValue: false, description: 'Force git tag creation (overrides !tag token)')
    booleanParam(name: 'ALWAYS_TAG',           defaultValue: true,  description: 'Create git tag for every version bump (ignores tokens)')
    booleanParam(name: 'ONLY_TAG_ON_MAIN',     defaultValue: false, description: 'Restrict tagging to main branch only')
    string      (name: 'RELEASE_BRANCH',       defaultValue: 'main', description: 'Branch name for tagging when ONLY_TAG_ON_MAIN=true')

    // GitHub Release controls (requires credentialsId)
    booleanParam(name: 'CREATE_GH_RELEASE',     defaultValue: false,  description: 'Force GitHub Release creation (overrides !release token)')
    booleanParam(name: 'GH_RELEASE_DRAFT',      defaultValue: false, description: 'Create GitHub Releases as drafts')
    booleanParam(name: 'GH_RELEASE_PRERELEASE', defaultValue: false, description: 'Mark GitHub Releases as prerelease')
    booleanParam(name: 'GH_GENERATE_NOTES',     defaultValue: false, description: 'Let GitHub auto-generate release notes')
    string      (name: 'GH_OWNER',              defaultValue: 'Kontra-tel', description: 'GitHub organization/user name')
    string      (name: 'GH_CREDENTIALS_ID',     defaultValue: 'Jenkins-Kontra', description: 'Jenkins credentials ID (GitHub App or PAT)')

    // Release notes controls
    booleanParam(name: 'NOTES_SINCE_LAST_TAG',   defaultValue: true,  description: 'Include commit notes since previous tag in release body')
    booleanParam(name: 'NOTES_INCLUDE_MERGES',   defaultValue: false, description: 'Include merge commits in release notes')
    string      (name: 'NOTES_MAX_COMMITS',      defaultValue: '200', description: 'Maximum commits to scan for release notes')
    booleanParam(name: 'ADD_COMPARE_LINK',       defaultValue: true,  description: 'Add GitHub compare link to release notes')
    booleanParam(name: 'FALLBACK_RELEASE_CREATES_TAG', defaultValue: true, description: 'Allow GitHub Release API to create tag if push fails')

    // Debug & git identity
    booleanParam(name: 'DEBUG_RELEASE',        defaultValue: false, description: 'Enable verbose logging for release/tag operations')
    string      (name: 'GIT_USER_NAME',        defaultValue: 'Jenkins CI', description: 'Git user.name for tag commits')
    string      (name: 'GIT_USER_EMAIL',       defaultValue: 'jenkins@local', description: 'Git user.email for tagging (fallback)')
  }

  environment {
    VERSION_FILE   = 'version.txt'
    CHANGELOG_FILE = 'CHANGELOG.md'
    // creds to read this repo when loading as a shared library
    GIT_READ_CREDS = 'Jenkins-Kontra'
  }

  stages {
    stage('Checkout') {
      steps { checkout scm }
    }

    stage('Load this repo as a library') {
      steps {
        script {
          // repo URL from current checkout
          def repoUrl = sh(script: 'git config --get remote.origin.url', returnStdout: true).trim()

          // Resolve a usable branch name:
          // 1) Multibranch env var, 2) local symbolic branch, 3) remote default HEAD, 4) fallback 'main'
          def branch = env.BRANCH_NAME?.trim()
          if (!branch) {
            branch = sh(script: 'git symbolic-ref --short -q HEAD || true', returnStdout: true).trim()
          }
          if (!branch || branch == 'HEAD') {
            branch = sh(
              script: 'git ls-remote --symref origin HEAD | awk \'/^ref:/ {sub("refs/heads/", "", $2); print $2; exit}\' || true',
              returnStdout: true
            ).trim()
          }
          if (!branch) { branch = 'main' }  // last-resort default

          // Use classic GitSCM so Jenkins actually checks out that branch for the lib
          def scmCfg = [
            $class: 'GitSCM',
            branches: [[name: "*/${branch}"]],
            doGenerateSubmoduleConfigurations: false,
            extensions: [],
            userRemoteConfigs: [[url: repoUrl]]
          ]
          if (env.GIT_READ_CREDS?.trim()) {
            scmCfg.userRemoteConfigs[0].credentialsId = env.GIT_READ_CREDS.trim()
          }

          library(identifier: "kontra-jenkins-lib@${branch}", retriever: legacySCM(scmCfg))
        }
      }
    }

    stage('Versioning (vars/semver.groovy)') {
      steps {
        script {
          // Compute version ONLY (no tags/releases here)
          def v = semver(
            strategy          : 'tag',                 // or 'file'
            versionFile       : env.VERSION_FILE,
            strictTagBaseline : params.STRICT_TAG_BASELINE,
            cumulativePatch   : params.CUMULATIVE_PATCH,
            // forced bump overrides
            forceMajor        : params.FORCE_MAJOR,
            forceMinor        : params.FORCE_MINOR,
            forcePatch        : params.FORCE_PATCH
          )

          currentBuild.displayName = "v${v.version}"
          echo "semver → version=${v.version} (base=${v.baseVersion}, src=${v.baselineSource}) bump=${v.bump}"

          writeFile file: env.VERSION_FILE, text: v.version + "\n"
          archiveArtifacts artifacts: env.VERSION_FILE, fingerprint: true

          sh "git log -1 --oneline || true"
        }
      }
    }

    stage('Unit tests (JenkinsPipelineUnit)') {
      steps {
        script {
          writeFile file: 'init.gradle', text: '''
allprojects {
  repositories {
    maven { url "https://repo.jenkins-ci.org/releases/" }
    mavenCentral()
  }
}
'''
          sh '''
            set -eu
            if [ -x ./gradlew ]; then
              echo "Using Gradle wrapper"
              ./gradlew --no-daemon --stacktrace --info -I init.gradle clean test
            else
              echo "Wrapper missing → system Gradle"
              gradle --no-daemon --stacktrace --info -I init.gradle clean test
            fi
          '''
        }
      }
      post {
        always {
          junit allowEmptyResults: true, testResults: 'build/test-results/test/*.xml'
          archiveArtifacts allowEmptyArchive: true, artifacts: 'build/reports/tests/test/**'
        }
      }
    }

    stage('Changelog (vars/generateChangelog.groovy)') {
      steps {
        script {
          def out = generateChangelog(
            outputFile: env.CHANGELOG_FILE,
            version   : env.BUILD_VERSION
          )
          echo "Changelog updated → ${out ?: 'no changes'}"
          archiveArtifacts artifacts: env.CHANGELOG_FILE, fingerprint: true
        }
      }
    }

    // Release comes AFTER tests (and will be skipped if tests are unstable/failing)
    stage('Release (vars/release.groovy)') {
      when {
        expression {
          // run only if build is SUCCESS so far (skip if UNSTABLE/FAILURE)
          (currentBuild.currentResult ?: 'SUCCESS') == 'SUCCESS'
        }
      }
      steps {
        script {
          // Tag/push and create GitHub release + notes since previous tag
          def rel = release(
            version                 : env.BUILD_VERSION,    // set by semver

            // Force tagging every build & push tags (independent of commit tokens)
            alwaysTag               : true,
            tagOnRelease            : true,
            forceRelease            : params.FORCE_RELEASE, // still allow manual force for metadata
            onlyTagOnMain           : false,                // tag every branch
            releaseBranch           : params.RELEASE_BRANCH,
            pushTags                : true,
            gitUserName             : params.GIT_USER_NAME,
            gitUserEmail            : params.GIT_USER_EMAIL,
            debug                   : params.DEBUG_RELEASE,

            // GitHub integration (still optional)
            credentialsId           : params.GH_CREDENTIALS_ID?.trim(),
            owner                   : params.GH_OWNER?.trim(),
            createGithubRelease     : params.CREATE_GH_RELEASE,
            releaseDraft            : params.GH_RELEASE_DRAFT,
            prerelease              : params.GH_RELEASE_PRERELEASE,
            generateReleaseNotes    : params.GH_GENERATE_NOTES,

            // Notes
            notesSinceLastTag       : params.NOTES_SINCE_LAST_TAG,
            notesIncludeMerges      : params.NOTES_INCLUDE_MERGES,
            notesMaxCommits         : params.NOTES_MAX_COMMITS,
            addCompareLink          : params.ADD_COMPARE_LINK,

            // Tag creation fallback (if push & Git API blocked)
            fallbackUseReleaseToCreateTag : params.FALLBACK_RELEASE_CREATES_TAG
          )
          echo "release → tag=${rel.tag} tagged=${rel.tagged} pushed=${rel.pushed} ghReleased=${rel.githubReleased} branch=${rel.branch}"
          sh "git tag -l | tail -n 5 || true"
        }
      }
    }

    stage('Smoke vars (optional)') {
      when { expression { fileExists('vars/writeEnvFile.groovy') && fileExists('vars/deploySystemd.groovy') } }
      steps {
        script {
          writeEnvFile(dryRun:true, path: "${pwd()}/.env", keys:['FOO','BAR'], data:[FOO:'1', BAR:'2'])
          deploySystemd(
            dryRun:true,
            service:'kontraLib-smoke',
            workingDir: "${pwd()}",
            installUnit:true, overwriteUnit:true, useSudo:false,
            execStart:"/usr/bin/env bash -lc 'echo hello from kontraLib'"
          )
        }
      }
    }
  }

  post {
    always { echo 'Pipeline completed.' }
  }
}
// End of Jenkinsfile
