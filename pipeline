// This Pipeline lives in the *library repo* itself.
// It bootstraps/loads this same repo as a Shared Library and invokes vars/* steps.

pipeline {
  agent any

  tools {
    jdk    'temurin-21'
    gradle 'Gradle 9.1.0-rc-2' // used only if wrapper is missing
  }

  options {
    timestamps()
    disableConcurrentBuilds()
    skipStagesAfterUnstable()   // <- do not run later stages (e.g., Release) if tests mark UNSTABLE
  }

  parameters {
    // Semver controls (versioning only)
    booleanParam(name: 'FORCE_MAJOR',          defaultValue: false, description: 'Force major version bump (!major)')
    booleanParam(name: 'FORCE_MINOR',          defaultValue: false, description: 'Force minor version bump (!minor)')
    booleanParam(name: 'FORCE_PATCH',          defaultValue: false, description: 'Force patch version bump (default)')
    booleanParam(name: 'STRICT_TAG_BASELINE',  defaultValue: false, description: 'Ignore version.txt; baseline only from tags')
    booleanParam(name: 'CUMULATIVE_PATCH',     defaultValue: false, description: 'Patch += commits since last tag (when baseline is a tag)')

    // Release controls (tagging / GitHub release)
    booleanParam(name: 'FORCE_RELEASE',        defaultValue: false, description: 'Force tagging this build as a release (!release)')
    booleanParam(name: 'ALWAYS_TAG',           defaultValue: false, description: 'Create a git tag for every bump')
    booleanParam(name: 'ONLY_TAG_ON_MAIN',     defaultValue: true,  description: 'Only tag on the main branch')
    string      (name: 'RELEASE_BRANCH',       defaultValue: 'main', description: 'Branch where tagging is allowed when ONLY_TAG_ON_MAIN=true')

    // GitHub integration (for release step)
    booleanParam(name: 'CREATE_GH_RELEASE',    defaultValue: false, description: 'Create/Update a GitHub Release for tagged versions')
    booleanParam(name: 'GH_RELEASE_DRAFT',     defaultValue: false, description: 'Create releases as drafts')
    booleanParam(name: 'GH_RELEASE_PRERELEASE',defaultValue: false, description: 'Mark releases as prerelease')
    booleanParam(name: 'GH_GENERATE_NOTES',    defaultValue: true,  description: 'Auto-generate release notes')
    string      (name: 'GH_OWNER',             defaultValue: 'Kontra-tel', description: 'GitHub org/user (helps GitHub App token inference)')
    string      (name: 'GH_CREDENTIALS_ID',    defaultValue: 'Jenkins-Kontra', description: 'CredentialsId (GitHub App or PAT) for pushing tags/releases')
  }

  environment {
    VERSION_FILE   = 'version.txt'
    CHANGELOG_FILE = 'CHANGELOG.md'
    // creds to read this repo when loading as a shared library
    GIT_READ_CREDS = 'Jenkins-Kontra'
  }

  stages {
    stage('Checkout') {
      steps { checkout scm }
    }

    stage('Load this repo as a library') {
      steps {
        script {
          // repo URL from current checkout
          def repoUrl = sh(script: 'git config --get remote.origin.url', returnStdout: true).trim()

          // Resolve a usable branch name:
          // 1) Multibranch env var, 2) local symbolic branch, 3) remote default HEAD, 4) fallback 'main'
          def branch = env.BRANCH_NAME?.trim()
          if (!branch) {
            branch = sh(script: 'git symbolic-ref --short -q HEAD || true', returnStdout: true).trim()
          }
          if (!branch || branch == 'HEAD') {
            branch = sh(
              script: 'git ls-remote --symref origin HEAD | awk \'/^ref:/ {sub("refs/heads/", "", $2); print $2; exit}\' || true',
              returnStdout: true
            ).trim()
          }
          if (!branch) { branch = 'main' }  // last-resort default

          // Use classic GitSCM so Jenkins actually checks out that branch for the lib
          def scmCfg = [
            $class: 'GitSCM',
            branches: [[name: "*/${branch}"]],
            doGenerateSubmoduleConfigurations: false,
            extensions: [],
            userRemoteConfigs: [[url: repoUrl]]
          ]
          if (env.GIT_READ_CREDS?.trim()) {
            scmCfg.userRemoteConfigs[0].credentialsId = env.GIT_READ_CREDS.trim()
          }

          library(identifier: "kontra-jenkins-lib@${branch}", retriever: legacySCM(scmCfg))
        }
      }
    }

    stage('Versioning (vars/semver.groovy)') {
      steps {
        script {
          // Compute version ONLY (no tags/releases here)
          def v = semver(
            strategy          : 'tag',                 // or 'file'
            versionFile       : env.VERSION_FILE,
            strictTagBaseline : params.STRICT_TAG_BASELINE,
            cumulativePatch   : params.CUMULATIVE_PATCH,
            // forced bump overrides
            forceMajor        : params.FORCE_MAJOR,
            forceMinor        : params.FORCE_MINOR,
            forcePatch        : params.FORCE_PATCH
          )

          currentBuild.displayName = "v${v.version}"
          echo "semver → version=${v.version} (base=${v.baseVersion}, src=${v.baselineSource}) bump=${v.bump}"

          writeFile file: env.VERSION_FILE, text: v.version + "\n"
          archiveArtifacts artifacts: env.VERSION_FILE, fingerprint: true

          sh "git log -1 --oneline || true"
        }
      }
    }

    stage('Unit tests (JenkinsPipelineUnit)') {
      steps {
        script {
          writeFile file: 'init.gradle', text: '''
allprojects {
  repositories {
    maven { url "https://repo.jenkins-ci.org/releases/" }
    mavenCentral()
  }
}
'''
          sh '''
            set -eu
            if [ -x ./gradlew ]; then
              echo "Using Gradle wrapper"
              ./gradlew --no-daemon --stacktrace --info -I init.gradle clean test
            else
              echo "Wrapper missing → system Gradle"
              gradle --no-daemon --stacktrace --info -I init.gradle clean test
            fi
          '''
        }
      }
      post {
        always {
          junit allowEmptyResults: true, testResults: 'build/test-results/test/*.xml'
          archiveArtifacts allowEmptyArchive: true, artifacts: 'build/reports/tests/test/**'
        }
      }
    }

    stage('Changelog (vars/generateChangelog.groovy)') {
      steps {
        script {
          def out = generateChangelog(
            outputFile: env.CHANGELOG_FILE,
            version   : env.BUILD_VERSION
          )
          echo "Changelog updated → ${out ?: 'no changes'}"
          archiveArtifacts artifacts: env.CHANGELOG_FILE, fingerprint: true
        }
      }
    }

    // Release comes AFTER tests (and will be skipped if tests are unstable/failing)
    stage('Release (vars/release.groovy)') {
      when {
        expression {
          // run only if build is SUCCESS so far (skip if UNSTABLE/FAILURE)
          (currentBuild.currentResult ?: 'SUCCESS') == 'SUCCESS'
        }
      }
      steps {
        script {
          // Tag/push and/or create GitHub release based on params & last commit
          def rel = release(
            version            : env.BUILD_VERSION,    // set by semver
            // tagging behavior
            alwaysTag          : params.ALWAYS_TAG,
            tagOnRelease       : true,                 // create tag when commit has !release OR FORCE_RELEASE
            forceRelease       : params.FORCE_RELEASE,
            onlyTagOnMain      : params.ONLY_TAG_ON_MAIN,
            releaseBranch      : params.RELEASE_BRANCH,
            pushTags           : true,
            // GitHub integration
            credentialsId      : params.GH_CREDENTIALS_ID?.trim(),
            owner              : params.GH_OWNER?.trim(),
            createGithubRelease: params.CREATE_GH_RELEASE,
            releaseDraft       : params.GH_RELEASE_DRAFT,
            prerelease         : params.GH_RELEASE_PRERELEASE,
            generateReleaseNotes: params.GH_GENERATE_NOTES
          )
          echo "release → tag=${rel.tag} tagged=${rel.tagged} pushed=${rel.pushed} ghReleased=${rel.githubReleased} branch=${rel.branch}"
          sh "git tag -l | tail -n 5 || true"
        }
      }
    }

    stage('Smoke vars (optional)') {
      when { expression { fileExists('vars/writeEnvFile.groovy') && fileExists('vars/deploySystemd.groovy') } }
      steps {
        script {
          writeEnvFile(dryRun:true, path: "${pwd()}/.env", keys:['FOO','BAR'], data:[FOO:'1', BAR:'2'])
          deploySystemd(
            dryRun:true,
            service:'kontraLib-smoke',
            workingDir: "${pwd()}",
            installUnit:true, overwriteUnit:true, useSudo:false,
            execStart:"/usr/bin/env bash -lc 'echo hello from kontraLib'"
          )
        }
      }
    }
  }

  post {
    always { echo 'Pipeline completed.' }
  }
}
// End of Jenkinsfile
