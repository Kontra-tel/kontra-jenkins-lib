// vars/writeEnvFile.groovy
def call(Map cfg = [:]) {
    if (!cfg.path) error "writeEnvFile: 'path' is required"

    final boolean dryRun    = (cfg.dryRun == true)
    final String  path      = cfg.path as String
    final Map     data      = (cfg.data instanceof Map) ? (Map)cfg.data : [:]
    final boolean sortKeys  = (cfg.sortKeys != false)
    final String  mode      = (cfg.mode ?: '600') as String
    final String  owner     = cfg.owner ?: null
    final String  group     = cfg.group ?: null
    final boolean useSudo   = (cfg.useSudo != false)

    // Robust keys handling (List, single String, comma/space separated String, or absent)
    def rawKeys = cfg.containsKey('keys') ? cfg.keys : []
    List<String> keys
    if (rawKeys instanceof List) {
        keys = ((List)rawKeys).collect { it?.toString() }
    } else if (rawKeys instanceof CharSequence) {
        def s = rawKeys.toString().trim()
        if (s.contains(',') || s.contains(' ')) {
            keys = s.split(/\s*,\s*|\s+/).findAll { it }
        } else if (s) {
            keys = [s]
        } else {
            keys = []
        }
    } else {
        keys = []
    }

    // Compose header lazily if not provided
    final String header = (cfg.header ?: {
        def ts = java.time.ZonedDateTime.now(java.time.ZoneId.of('UTC'))
            .format(java.time.format.DateTimeFormatter.ofPattern('yyyy-MM-dd HH:mm:ss'))
        "# Autogenerated by Jenkins on ${ts} UTC (${env.JENKINS_URL ?: 'jenkins'})"
    }()) as String

    // Determine keys to write (explicit keys or from data) and optionally sort CPS-safe
    List<String> keysToWrite = (keys && !keys.isEmpty()) ? keys : data.keySet().collect { it.toString() }
    if (sortKeys && keysToWrite) {
        keysToWrite = new ArrayList<>(keysToWrite)
        java.util.Collections.sort(keysToWrite)
    }
    List<String> lines = [header]

    def sanitizeKey = { String k ->
        k?.toUpperCase()?.replaceAll(/[^A-Z0-9_]/, '_')
    }
    def q = { String v ->
        if (v == null) { v = '' }
        // escape backslashes and double quotes; fold newlines
        v = v.replace('\\', '\\\\').replace('\"', '\\\"').replace('\r\n', '\n').replace('\n', '\\n')
        "\"${v}\""
    }
    def valFor = { String k ->
        if (data.containsKey(k)) {
            return data[k]?.toString()
        }
        return env[k] // may be null
    }

    keysToWrite.each { k ->
        def key = sanitizeKey(k)
        def val = valFor(k)
        lines << "${key}=${q(val)}"
    }

    def content = lines.join('\n') + '\n'

    if (dryRun) {
        // Stage content only (no install), emulate writeFile to target path for tests if desired
        writeFile file: path + '.dryrun', text: content
        echo "writeEnvFile(dryRun): would write ${keysToWrite.size()} keys to ${path}"
        return [dryRun: true, path: path, keys: keysToWrite, content: content]
    }

    // write to workspace first
    def tmp = ".tmp.env.${UUID.randomUUID()}"
    writeFile file: tmp, text: content

    // install atomically with proper perms (and owner/group if provided)
    def sudo = useSudo ? 'sudo ' : ''
    def og   = (owner || group) ? "-o ${owner ?: ''} -g ${group ?: ''}" : ''
    sh "${sudo}install -m ${mode} ${og} ${tmp} ${path}"
    sh "rm -f ${tmp}"

    echo "writeEnvFile: wrote ${keysToWrite.size()} keys to ${path} " +
         "(mode ${mode}" +
         "${owner ? ", owner ${owner}" : ''}" +
         "${group ? ", group ${group}" : ''})"
    return [dryRun: false, path: path, keys: keysToWrite, content: content]
}
