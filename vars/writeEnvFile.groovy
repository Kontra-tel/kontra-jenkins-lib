// vars/writeEnvFile.groovy
def call(Map cfg = [:]) {
    if (!cfg.path) {
        error "writeEnvFile: 'path' is required"
    }
    def dryRun     = (cfg.dryRun == true)
    def path       = cfg.path as String
    // Normalize keys: accept List, single String, comma-separated String, or empty
    def keysInput = cfg.keys
    List keys
    if (keysInput instanceof CharSequence) {
        def s = keysInput.toString().trim()
        if (s.contains(',')) { keys = s.split(',').collect { it.trim() }.findAll { it } }
        else if (s) { keys = [s] } else { keys = [] }
    } else if (keysInput instanceof Collection) {
        keys = (keysInput as Collection).collect { it?.toString() }.findAll { it }
    } else {
        keys = []
    }
    def data       = (cfg.data ?: [:]) as Map   // optional explicit keyâ†’value map (overrides env)
    def header     = cfg.header ?: ({
        def ts = java.time.ZonedDateTime.now(java.time.ZoneId.of('UTC'))
                   .format(java.time.format.DateTimeFormatter.ofPattern('yyyy-MM-dd HH:mm:ss'))
        return '# Autogenerated by Jenkins on ' + ts + ' UTC (' + (env.JENKINS_URL ?: 'jenkins') + ')'
    })()
    def sortKeys   = (cfg.sortKeys == false) ? false : true
    def mode       = cfg.mode ?: '600'
    def owner      = cfg.owner ?: null
    def group      = cfg.group ?: null
    def useSudo    = (cfg.useSudo == false) ? false : true

    // build lines
    List<String> lines = [header]
    List<String> keysToWrite = []
    if (keys && !keys.isEmpty()) {
        keysToWrite = keys.collect { it as String }
    } else {
        keysToWrite = (data.keySet() as List<String>)
    }
    if (sortKeys) {
        keysToWrite = keysToWrite.sort { it }
    }

    def sanitizeKey = { String k ->
        k?.toUpperCase()?.replaceAll(/[^A-Z0-9_]/, '_')
    }
    def q = { String v ->
        if (v == null) { v = '' }
        // escape backslashes and double quotes; fold newlines
        v = v.replace('\\', '\\\\').replace('\"', '\\\"').replace('\r\n', '\n').replace('\n', '\\n')
        "\"${v}\""
    }
    def valFor = { String k ->
        if (data.containsKey(k)) {
            return data[k]?.toString()
        }
        return env[k] // may be null
    }

    keysToWrite.each { k ->
        def key = sanitizeKey(k)
        def val = valFor(k)
        lines << "${key}=${q(val)}"
    }

    def content = lines.join('\n') + '\n'

    if (dryRun) {
        // Stage content only (no install), emulate writeFile to target path for tests if desired
        writeFile file: path + '.dryrun', text: content
        echo "writeEnvFile(dryRun): would write ${keysToWrite.size()} keys to ${path}"
        return [dryRun: true, path: path, keys: keysToWrite, content: content]
    }

    // write to workspace first
    def tmp = ".tmp.env.${UUID.randomUUID()}"
    writeFile file: tmp, text: content

    // install atomically with proper perms (and owner/group if provided)
    def sudo = useSudo ? 'sudo ' : ''
    def og   = (owner || group) ? "-o ${owner ?: ''} -g ${group ?: ''}" : ''
    sh "${sudo}install -m ${mode} ${og} ${tmp} ${path}"
    sh "rm -f ${tmp}"

    echo "writeEnvFile: wrote ${keysToWrite.size()} keys to ${path} " +
         "(mode ${mode}" +
         "${owner ? ", owner ${owner}" : ''}" +
         "${group ? ", group ${group}" : ''})"
    return [dryRun: false, path: path, keys: keysToWrite, content: content]
}
